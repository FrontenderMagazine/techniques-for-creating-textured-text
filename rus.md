# Техника создания текстурного текста

В этой статье мы рассмотрим несколько приёмов, которые могут быть использованы 
для создания текстурного текста или добавления фона для текста. 

*Пожалуйста учтите, что некоторые приёмы, описанные в статье, являются 
экспериментальными, плохо поддерживаются браузерами и будут не лучшим выбором 
для использования в реальных проектах, в которых нужна хорошая поддержка 
браузеров.*

Для каждого примера я добавил скриншот и ссылку в конце описания каждого из них. 
Чтобы просмотреть пример, можно также кликнуть по соответствующему скриншоту.

## Применение фонового изображения для текста посредством использования `-webkit-background-clip: text`

Мы начнём с CSS-свойства `background-clip`, применение которого даёт следующий 
результат:

![пример №1][текстурный текст]

[CSS-свойство `background-clip`][1] определяет **область закрашивания фона** 
элемента, т.е. область, внутри которой прорисовывается фон. По умолчанию, фон 
занимает всё пространство между границами элемента со значением `border-box` и 
может принимать другие значения такие как `padding-box` и `content-box`. 

С помощью этого свойства могут быть реализованы различные эффекты вроде 
[установки прозрачных границ элемента][2] и оно довольно [хорошо поддерживается][3] 
во всех современных браузерах.

[В Webkit][4] для свойства `background-clip` добавлено четвёртое значение, `text`, 
которое **обрезает фоновое изображение по тексту на переднем плане** (с учётом 
декоративных элементов и теней). Если в придачу к обрезке фона для текста 
установить прозрачный цвет шрифта, используя Webkit-свойство 
`-webkit-text-fill-color`, сквозь текст будет видно фоновое изображение.  

На момент написания статьи значение `text` свойства `background-clip` **не было 
внесено ни в один стандарт, так что, к сожалению, оно работает только в 
браузерах на движке WebKit**, для других браузеров можно использовать простой 
фолбек на основе CSS или же [полифил][5].

Мы пока создадим текст с фоном используя свойство `-webkit-background-clip` и 
пропишем фолбек на основе CSS, благодаря которому в браузерах на движках 
отличных от WebKit, будет видно [текст на фоне картинки][6]. 

Для нашего примера (см. скриншот выше) мы будем использовать элемент с фоном и 
заголовок первого уровня внутри него; нам нужно обрезать фон так, чтобы казалось 
будто он применён только для текста внутри элемента.
   
    <div class="container">
        <!-- элемент, фон которого нам нужно обрезать -->
        <div class="clipped">
            <h1>CO<br/>OK</h1>
        </div>
        <!-- произвольный контент -->
        <p><span>The #1 cooking magazine in the world.</span> New healthy and delicious recipes every week. Subscribe to the weekly issue of COOK magazine and stay up-to-date on the latest kitchen trends and tips anc tricks from the world's #1 chefs. <br/>
        Download our app available for Android, iOS and Windows phones.</p>
    </div>

Мы будем использовать «жирный шрифт», чтобы сквозь текст было лучше видно фон. 
Устанавливаем для элемента `.clipped` фоновое изображение, которое обрезаем по 
контуру текста используя значение `text` свойства `background-clip`. Цветом 
текста установим белый, так как браузеры не на движке WebKit, будут отображать 
текст на фоне изображения и нам нужно выбрать цвет шрифта, который будет хорошо 
на нём читаться. Затем пропишем прозрачность в качестве цвета заливки текста, 
это правило отменит белый цвет текста в браузерах на WebKit так, что фоновое 
изображение будет видно сквозь текст. 
    
    .clipped {
        background: url(../img/kitchen.jpg) no-repeat center center;
        background-size: cover;
        color: #fff;
        text-align: center;
        padding: 2em;
        /* -webkit-background-clip обрезает фон элемента по контуру текста */
        -webkit-text-fill-color: transparent; /* переопределяет цвет текста с белого на прозрачный в браузерах на webkit */
        -webkit-background-clip: text;
    }

**Взгляните на пример 1: [Текст с фоном, используется `background-clip:text`][7]**

Если вы просматриваете пример в браузере не на движке WebKit, то должны увидеть 
белый текст на фоне изображения. 

В случаях когда изображение играет важную роль в передаче визуального посыла, 
отображение фонового изображения под непрозрачным текстом - это наверное самый 
лучший фолбек для браузеров не на движке WebKit. Однако при желании можно также 
как фолбек отобразить обычный текст без фонового изображения. Дивья Маниан 
(Divya Manian) написала [отличную статью][8], с объяснением как можно создать 
такой фолбек с обычным текстом, а Рейчел Нэйборс создала миксин для Sass на 
основе кода Дивьи, он [доступен на Codepen][9].

Так же как и фоновое изображение, для текста в качестве фона можно применить 
градиент. Так как градиенты в CSS приравниваются к изображению, в примере выше 
их можно прописать для элемента `.clipped`, в результате чего получим текст с 
градиентом в качестве фона. Ризе Сельчук Сайдам (Riza Selçuk Saydam) создал 
очень хороший [интерактивный пошаговый пример на Codepen][10], который объясняет 
как можно создать текст с градиентом. Взгляните на него если вам требуется 
визуальное объяснение этого приёма.

## Применение текстуры для текста с помощью `mask-image: url();`

Следующий приём на CSS, который мы рассмотрим, также на данный момент 
поддерживается только браузерами на WebKit (см. [таблица поддержки браузерами][11]) 
с префиксом `-webkit`.

Мы будем использовать **CSS-маски** для создания красивого эффекта текстурного 
текста. [CSS-маски являются рабочим черновиком W3C][12], так что есть надежда, 
что в скором времени и другие браузеры будут их поддерживать.

Однако пока мы создадим пример, которое будет работать только в браузерах на 
WebKit и добавим простой фолбек для браузеров, которые его не поддерживают. Мы 
будет использовать [CSS-свойство `mask-image`][13] для применения к тексту 
эффекта брызг чтобы получить следующий результат:

![пример№2][текст с эффектом акварельных пятен]

**При использовании CSS-масок мы принуждаем текст принять форму 
изображения-маски, вместо того чтобы изображение принимало форму текста как в 
случае с приёмом `background-clip`, описанным выше.**

Свойство `mask-image` принимает одно из трёх значений: изображение с 
альфа-прозрачностью, прозрачные участки которого будут участками, где контент не 
будет отображаться, CSS-градиент или `none`. Для нашего примера мы будем 
использовать изображение с альфа-прозрачностью, которое выглядит так:

![splatter-mask_1-codrops][изображение с альфа-прозрачностью]

На изображении представлен ряд клякс, которые мы применим к тексту, чтобы он 
выглядел так, будто на нём есть пятна акварели. В браузерах, которые не 
поддерживают данную технику, текст будет отображаться без эффекта акварельных 
пятен. 

Если применить эту маску к тексту или любому другому контенту, текст будет виден 
на месте чёрных пятен; на прозрачных участках текст отображаться не будет. 
Представьте, что текст (или контент) и маска - это слои, а теперь представьте, 
что мы помещаем изображение-маску над текстом и ластиком стираем части текста, 
которые не перекрываются этими чёрными пятнами, в результате у нас получится 
текст с маской как на скриншоте выше.

Чтобы эффект был более реалистичным, я добавил для элемента, содержащего текст, 
акварельный фон, который будет просвечивать в местах, где текст «стёрт», таким 
образом создавая красивый переход текста в фон. Для всего этого используется 
только CSS. Неплохо, да? Очень жаль что на данный момент поддержка этой техники 
оставляет желать лучшего. Однако в следующей части статьи мы поговорим о том, 
как можно сделать такой эффект кросс-браузерным.

Сейчас у нас для нашего примера есть контейнер, в который обёрнуты два заголовка:
    
    <div class="container>
      <h1>Art</h1>
      <h2>Digital Magazine</h2>
    </div>

Мы применим эффект брызг к элементу `h1`. Вот соответствующий CSS для этого 
эффекта:
  
    .container h1 {
        font: 35em/100% "Oswald", sans-serif;
        margin: 0 auto;
        padding: 0;
        text-align: center;
        color: #fff;
        /* свойство, которое создаёт эффект брызг */
        -webkit-mask-image: url(../img/splatter-mask_1.png);
        mask-image: url(../img/splatter-mask_1.png);
    }

Вот и всё что нужно, чтобы достичь такого эффекта. Теперь вы наверняка захотите 
добавить немного дополнительной стилизации в зависимости от конечного эффекта, к 
которому стремитесь, как сделал я в примере, однако эта строчка CSS является 
самой важной при использовании маски для добавления текстуры для текста.

Необходимо отметить, что когда это свойство будет поддерживаться другими 
браузерами, возможно вам потребуется добавить не только префикс `-webkit-`, но и 
другие. На момент написания статьи чтобы приём работал, нужно использовать 
префикс `-webkit-` и если вы решите использовать его в своём проекте, помните о 
необходимости обновлять код после внесения изменений в спецификации или 
изменения в поддержке браузерами.

**Взгляните на пример 2: [Текстурный текст с применением `mask-image`][14].**

Фолбеком для этого примера в не поддерживающих его браузерах является обычный 
текст на изображении.

Больше о CSS-масках можно почитать в [спецификации W3C][15], кроме того 
взгляните на ещё один искусный пример текстурного текста в [этой статье][16] 
Трента Уолтона (Trent Walton).

## Создание текстурного текста с помощью SVG

Оба предыдущих эффекта можно воссоздать используя SVG, к тому же в обеих случаях 
результат, полученный с помощью SVG, будет кросбраузерным. Следовательно этот 
метод можно использовать в качестве фолбека для браузеров, которые не 
поддерживают два CSS-свойства, описанные выше. 

### Обрезка фона по контуру текста с использованием `<clippath>` SVG

Для начала мы используем элемент `<clippath>` и SVG для воссоздания эффекта от 
`background-clip: text`.

![пример№3][текст с обрезанным по его контуру фоном]

[Контур обрезки][17] определяет профиль или область, для которой будет применён 
фон. Части фона, выходящие за рамки определённого очертания, не будут 
отображаться, в отличии от тех, что находятся внутри него. 

Контур обрезки может принимать несколько значений, одно из них - элемент `<text>`. 
Когда в качестве контура обрезки указан текстовый элемент, фон обрезается по 
очертаниям текста.

Когда контур обрезки определён (мы перейдём к коду через минуту), к нему можно 
обратиться с помощью `clip-path` в качестве атрибута изображения, которое мы 
хотим обрезать или CSS-свойства этого изображения.

Начнём с определения контура, по которому мы хотим обрезать наше изображение. В 
нашем случае это будет одно слово, через которое должно просвечивать фоновое изображение. 

Сначала мы создадим элемент `SVG`, содержащий весь наш SVG-код. Затем определим 
контур обрезки и применим его для элемента `image` через атрибут `clip-path`:
    
    <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1200" height="400" viewBox="0 0 1200 400">
        <!-- добавление заголовка для улучшения доступности -->
        <title>Добавление фона для текста с использованием SVG clipPath</title>
        <defs> 
          <clippath id="my-path">
            <text x="50" y="300" font-size="200" >WATERCOLOR</text>
          </clippath>
        </defs>
        <image xlink:href="img/watercolor_1.jpg" clip-path="url(#test)" width="100%" height="100%" preserveAspectRatio="none" />
    </svg>

*Поскольку элемент SVG является по сути графическим элементом, не забудьте 
добавить заголовок, чтобы сделать его доступным для скринридеров.*

В коде выше мы создали элемент `text`, прописали для него размер шрифта и 
указали координаты по оси x и y, которые определяют где внутри SVG будет 
отрисован текст. Затем мы разместили текстовый элемент внутри элемента `clippath`, 
которому был присвоен ID, чтобы к нему можно было обратиться. Затем мы поместили 
элемент `clippath` внутрь элемента `defs`. Элемент `defs` может быть использован 
для хранения контента, который не отображается напрямую. Этот скрытый контент 
может быть вызван и отображён другими элементами SVG, что делает его идеальным 
для хранения шаблонов с графическими элементами многократного использования. В 
нашем случае он идеально подходит для *определения* контура обрезки, к которому 
мы хотим обратиться через атрибут нашего элемента с изображением.

Затем мы добавили изображение, прописали для него ширину и высоту и установили 
для `preserveAspectRatio` значение `none` чтобы соотношение сторон не было 
фиксированным, ведь будь оно таковым, высота и ширина не применялись бы при 
нарушении соотношения сторон.

И наконец, мы вызываем ранее определённый контур обрезки используя атрибут 
`clip-path` для изображения. Атрибут `clip-path` принимает идентификатор 
элемента `clippath` в качестве значения и применяет контур обрезки для 
изображения.

**Взгляните на пример 3: [Фон текста с использованием `<clippath>`][18].**

Вместо того, чтобы использовать атрибут `clip-path` для применения контура 
обрезки к изображению, можно также применить его с помощью CSS таким образом:
   
    image {
        clip-path: url(#my-path);
    }

Этот подход должен работать как следует во всех современных браузерах: Chrome, 
Safari, Opera, Firefox и IE9+. Значит если вы хотите использовать CSS-свойство 
`background-clip: text;`, можете, например, проверить поддержку 
`background-clip: text` браузером с помощью [Modernizr][19] и предоставить 
фолбек в виде SVG для неподдерживающих браузеров. Нечто в этом роде делает 
[полифил][20], который создал Тим Петруски (Tim Pietrusky), однако вместо 
фонового изображения и его обрезки с помощью `clippath`, используется приём с 
SVG, согласно которому текст заполняется фоновым изображением, которое по 
изначальной задумке должно было быть обрезано. В следующей части мы рассмотрим 
способ заливки текста узором в SVG.

### Применение фона для текста посредством его заливки с помощью элемента `<pattern>`

Ещё один способ применить фон или узор для текста - это *заливка* текста узором, 
вместо использования фонового изображения и обрезки его под текст. Для этого 
примера мы зальём текст узором, имитирующим дерево, который я скачал с 
[SubtlePatterns][21].

![пример№4][текст с узором, имитирующим дерево]

Использование изображения и обрезка его под текст может быть наиболее удачным 
подходом при использовании декоративных шрифтов как в нашем первом примере, где 
нам нужно было чтобы сквозь текст просвечивалась большая часть изображения, так 
как это изображение играло роль в формировании характера нашего примера. Однако 
иногда нам нужно всего лишь добавить для текста простой и малозаметный узор 
чтобы сделать его более красивым и менее скучным. В таком случае используя SVG 
мы можем определить узор точно так же как определили контур обрезки в предыдущей 
части, а затем мы можем использовать этот узор для *заливки* текста.

Так же как и в предыдущем примере, у нас есть SVG-элемент с заголовком для 
доступности, элемент `text`, который мы хотим заполнить узором и элемент `defs`, 
который мы будем использовать для *определения* узора. Узор состоит из 
изображения `image` и имеет идентификатор, который позже будет использован для 
обращения к нему и применения к нашему тексту. Узор будет вызываться через 
атрибут `fill` внутри элемента с текстом или через CSS-свойство `fill`.
    
    <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="700" height="400" >
        <!-- добавление заголовка для доступности -->
        <title>Применения для текста фона с узором в SVG</title> -->
        <!-- Источник: http://lea.verou.me/2012/05/text-masking-the-standards-way/ -->
        <defs>
            <pattern id="filler" patternUnits="userSpaceOnUse" width="400" height="400" >
                <image xlink:href="img/purty_wood.png" width="1200" height="600" preserveAspectRatio="none" />
            </pattern>
        </defs>
        <text x="100" y="70%" font-size="200" fill="url(#filler)">WOOD</text>
    </svg>

Так же как и в предыдущем примере, к узору можно обратиться через CSS вот так:
    
    text {
        fill: url(#filler);
    }

**Взгляните на пример 4, которое работает во всех современных браузерах, в 
действии: [Фон для текста посредством заполнения изображением SVG][22].**

На этом этапе нужно отметить, что в качестве узора в SVG можно использовать не 
только изображение; поскольку градиенты, как мы уже отмечали выше, также 
являются изображением, можно создать SVG-градиент и использовать его для заливки 
текста:

![пример№5][текст, залитый градиентом]

Создать и использовать градиент в SVG очень просто. Градиент создаётся как 
элемент `radialGradient` или `linearGradient`, ему присваивается идентификатор, 
затем для обращения к нему используется атрибут `fill` или CSS-свойство, как мы 
делали выше для `<pattern>`. Вот простой пример где градиент используется для 
заливки текста.

**Взгляните на [пример 5][23], в котором продемонстрирована заливка текста 
градиентом.**

И конечно же, градиент можно установить фоновым изображением контейнера, а затем 
обрезать фон с помощью `clippath`, как мы делали в предыдущей части.

### Применение текстуры для текста с помощью SVG `<mask>`

![пример№6][текст с эффектом акварели]

Точно так же как мы применили маску из изображения для элемента с помощью 
CSS-свойства `mask-image`, можно использовать те же приёмы применения маски и 
добиться того же эффекта с помощью [SVG маски][24].

Изображение с прозрачными и непрозрачными участками определяет места, где будет 
отрисовываться текст, так как мы видели в предыдущей части в которой применялось 
CSS-свойство `mask-image`. Между CSS-масками и SVG-масками однако есть одно 
важное отличие: **при использовании SVG-маски, области отрисовки определяются не 
значением альфа-канала, а значением яркости, в отличие от CSS-маски**. 
Следовательно, изображение с чёрными и прозрачными кляксами, которое мы 
использовали в качестве маски выше, нужно заменить на изображение с белыми и 
прозрачными участками. Итак, для того чтобы воссоздать эффект акварельного 
текста, представленный ранее, нам придётся использовать изображение-маску вроде следующего:

![маска яркости][маска яркости]

Изображение-маску с альфа-каналом можно без проблем переделать в маску яркости в 
программе Photoshop посредством применения перекрытия белым цветом, что 
превратит чёрные участки в белые, именно это я сделал чтобы заменить изображение 
для CSS-маски более подходящим для SVG-маски. Светло-серые участки, видимые на 
изображении выше, на самом деле являются прозрачными, я всего лишь добавил этот 
фон для изображения чтобы вы могли увидеть белые кляксы, которые в противном 
случае не были бы видны на белом фоне этой статьи.

Теперь так же как определяли контур обрезки и узор SVG, мы можем определить нашу 
маску и применить её к тексту. 

Мы создадим `image`, обёрнутый в SVG-элемент `mask`, которому будет присвоен 
идентификатор чтобы к нему можно было обратиться, и `mask` обернём в элемент 
`defs`, который используется для определения маски без её непосредственного 
отображения.

Можно сказать, что мы определяем (`defs`) SVG-маску (`mask`), которая является 
изображением (`image`) со следующим адресом (URL маски яркости, созданной ранее) 
и затем применяем эту маску к нашему тексту используя атрибут `mask` элемента 
`text` или, конечно же, через CSS, используя свойство `mask`.
  
    <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1000" height="380" >
        <!-- добавляем заголовок для доступности -->
        <title>Добавление текстуры для текста с использованием SVG-маски</title>
            <defs>
                <mask id="mask">
                    <image width="1200px" height="1200px" xlink:href="img/splatter-mask_luminance.png" preserveAspectRatio="none"/>
                </mask>
            </defs>
        <text x="50" y="70%" font-size="168" fill="white" mask="url(#mask)">WATERCOLOR</text>
    </svg>

Для большей эффектности я добавил фон с акварелью для главного элемента `svg`, 
чтобы казалось, что текст переходит в фон. 

**Взгляните на кроссбраузерный результат в [примере 6][25].**

Если хотите, можете почитать больше о комбинировании CSS и SVG масок в [этой 
прекрасной статье][26] Кристиана Шефера (Christian Schaefer), опубликованной в 
блоге The Nitty Gritty. SVG-маски обладают гораздо большим потенциалом, ведь всё 
становится ещё интересней если в качестве маски применить, к примеру, 
[анимированный фон на основе `canvas`][27].

## Создание текстурного текста в помощью HTML5 `<canvas>`

Последняя техника, которую мы рассмотрим, предусматривает использование HTML5 
элемента `<canvas>` для создания описанных выше эффектов. С помощью `<canvas>` 
можно обрезать один элемент по контуру другого, залить текст текстурой и 
применить для текста эффект вроде маски, изменив значение свойства 
`globalCompositeOperation` контекста `<canvas>`.

Перед тем как погрузиться в разбор технических особенностей, давайте определимся 
с разметкой, так как она будет одинаковой для всех трёх техник, которые мы будем 
рассматривать. 

У нас есть элемент `<canvas>`, для которого мы указываем высоту и ширину и перед 
закрывающим тегом добавим текстовый контент, который смогут прочитать 
скринридеры, а также будет использоваться браузерами с отключённым JavaScript в 
качестве фолбека. Здесь однако следует отметить, что в Firefox этот текст не 
отображается в качестве фолбека когда JavaScript отключён, что [вероятно 
является ошибкой][28].
    
    <canvas id="canvas" width=1000 height=600 >
     <!-- резервный контент для доступности и для браузеров без js -->
      WATER
    </canvas>

Теперь когда у нас готова разметка, нарисуем текстурный текст.

Для нашего первого примера мы создадим текст в `<canvas>` и **зальём** его 
выбранным узором чтобы получить следующий результат:

![пример№7][текст с водной текстурой]

Нам нужен элемент `<canvas>` и его контекст отрисовки, затем мы добавим 
изображение и используем его для заливки нашего текста.
  
    var canvas = document.getElementById("canvas");
    var ctx = canvas.getContext("2d");
    //добавляем изображение, которое будет использоваться как узор заливки
    var img = document.createElement("img");
    img.src="img/water.jpg";
    //отрисовка текста
    img.onload= function(){
      drawText();
    }
    //функция, которая отрисовывает текст и заливает его текстурой из img
    function drawText() {
        ctx.font = "bold 200pt Oswald";
        ctx.fillStyle = ctx.createPattern(img, 'repeat');
        ctx.textAlign = 'center';
        var x = canvas.width / 2;
        ctx.fillText("WATER", x, 400);
        ctx.fill();
    }

Давайте пройдёмся по коду выше. Вся отрисовка происходит в функции `drawText`. 
Мы определим стиль шрифта в свойстве `font`, а затем используя метод 
`createPattern`, из изображения, созданного выше, создадим узор и установим его 
в качестве значения для свойства `fillStyle`, которое определяет **стиль заливки** 
для шрифта. И наконец, мы отрисуем текст в `<canvas>` используя метод `fillText`, 
принимающий строку, которая является текстом, что должен быть отрисован и 
несколько координат по x и y, которые, как вы уже наверное догадались, 
определяют в каком месте `<canvas>` будет отрисован текст.

Взгляните на [пример 7][29] в действии.

Нужно отметить одну деталь: если вы используете в `<canvas>` подключённый шрифт, 
он может не отображаться, поскольку отрисовка `<canvas>` может произойти до того, 
как будет загружен шрифт. Чтобы этого избежать, можно, например, использовать 
загрузчик шрифтов вроде загрузчика [Web Font Loader][30], созданного 
разработчиками из Typekit и Google и отрисовывать `<canvas>` *после* загрузки 
шрифта:
    
    WebFontConfig = {
        google: { families: [ 'Oswald' ] },
        fontactive: function() {
            var canvas = document.getElementById("canvas");
            var ctx = canvas.getContext("2d");
            var img = document.createElement("img");
            img.src="img/water.jpg";
         
            img.onload= function(){
                drawText();
            }
 
            function drawText() {
                ctx.font = "bold 200pt Oswald";
                ctx.fillStyle = ctx.createPattern(img, 'repeat');
                ctx.textAlign = 'center';
                var x = canvas.width / 2;
                ctx.fillText("WATER", x, 400);
            }
        }
    };
    (function() {
        var wf = document.createElement('script');
        wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
         '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
        wf.type = 'text/javascript';
        wf.async = 'true';
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(wf, s);
    })();

*Эта техника используется во всех примерах, однако я не хочу всё усложнять, 
потому в следующих примерах представлю вам только те функции, которые имеют 
отношение к соответствующему приёму.*

Перейдём к следующему приёму. Мы создадим эффект похожий на обрезку для нашего 
`<canvas>` изменив значение свойства `globalcompositeOperation` нашего контекста. 
Конечный результат будет выглядеть так:

![пример№8][текст с огненной текстурой]

У контекста `<canvas>` есть свойство `globalcompositeOperation`, которое 
определяет композиционные операции между так зваными «исходным элементом» и 
«целевым элементом». То есть, она определяет как то, что вы хотите нарисовать 
будет сочетаться с тем, что уже нарисовано в `<canvas>`. **Исходный элемент - 
это то, что вы хотите нарисовать, а целевой элемент - это то, что уже нарисовано 
до настройки свойства `globalCompositeOperation`**. С помощью этого свойства 
можно нарисовать новые элементы и фигуры под уже существующими, скрыть некоторые 
участки с помощью маски, а также очистить некоторые участки `<canvas>`.

`globalCompositeOperation` может принимать одно из 16 значений, каждое из 
которых хорошо продемонстрировано в [визуальном примере][31] на MDN. Если вам 
ещё не приходилось работать с этим свойством, обязательно взгляните на этот 
пример, так как он поможет лучше разобраться со свойствами, которые мы будем 
использовать дальше. Вот скриншот результата применения каждого из этих значений. 
В исходном коде примера «целевой элемент» является синим прямоугольником, 
который нарисован на `<canvas>` первым, а «исходный элемент» - красный круг, 
который нарисован после указания значения для `globalCompositeOperation`.

![композиция холста][примеры композиции canvas]

На простом языке значение `source-in` этого свойства можно интерпретировать как 
«отрисовка участков/областей исходного и целевого элементов в местах их 
пересечения». Итак, если у вас есть два элемента, один из них уже нарисован, а 
другой вы собираетесь нарисовать, отображаться будут только те участки, где эти 
два элемента пересекаются.

Чтобы понять это лучше, давайте сразу же погрузимся в код.
    
    var canvas = document.getElementById("canvas");
    var ctx = canvas.getContext("2d");
 
    var img = document.createElement("img");
    img.onload = function () {
       drawText();
    }
    img.src="img/fire.jpg";
    function drawText() {
   
        // добавление текста в canvas
        ctx.font = "bold 180pt IM Fell Great Primer SC";
        ctx.fillStyle = 'white';
        ctx.textAlign = 'center';
        var x = canvas.width / 2;
        ctx.fillText("FIRE", x, 325);
 
        // используем композицию чтобы фоновое изображение отрисовывалось только там, где отрисован текст
        ctx.globalCompositeOperation = "source-in";
        ctx.drawImage(img, 0, 0, img.width, img.height, 0, 0, canvas.width, canvas.height);
    }

В коде выше внутри функции `drawText` у нас есть 3 «секции», которые определяют 
что будет в результате отрисовано в `<canvas>`. В первой секции мы указываем 
текст, а также все его стилевые свойства, а затем отрисовываем его с помощью 
метода `fillText`. Затем мы устанавливаем для `globalCompositeOperation` нашего 
контекста значение `source-in`. Затем мы добавляем в `<canvas>` изображение.

Итак вы видите, что «исходный элемент» в этом случае - это элемент, который 
должен быть добавлен после установки значения для `globalCompositeOperation`
(изображение), а «целевой элемент» - это текст, который был добавлен перед ней. 
Устанавливая значение `source-in`, мы говорим браузеру, что следует отрисовывать 
изображение только в тех местах, где оно пересекается с текстом, именно так мы 
получаем нужный нам эффект обрезки.

Как только разберётесь со всеми значениями `globalCompositeOperation`, сможете 
использовать их быстро и легко; также не забудьте просмотреть визуальные примеры 
на MDN, они вам в этом здорово помогут.

Когда будете их просматривать, заметите что если установить значение 
`source-atop` в нашем примере, результат будет тем же. `source-atop` говорит 
браузеру что нужно отрисовывать участки/области исходного элемента (изображения) 
там, где он пересекается с целевым элементом (текстом), а также что нужно 
отрисовывать остальные части целевого элемента, даже если они не пересекаются с 
исходным элементом, что в нашем случае даёт все тот же желанный для нас 
результат.

**Взгляните на [пример 8][32] для этого приёма.**

Примечание: на момент написания этой статьи не все значения свойства 
`globalCompositeOperation` поддерживаются всеми современными браузерами без 
исключения. Кроссбраузерными являются шесть значений (они работают в Chrome, 
Safari, Firefox и Opera): `source-over`, `source-atop`, `destination-over`, 
`destination-out`, `lighter` и `xor`. Больше информации об этом есть [здесь][33]. 
Более сложные примеры использования свойства `globalCompositeOperation` для 
подробного изучения создания очень крутых типографических эффектов с помощью 
`canvas` можно найти в [этой публикации][34] на HTML5Rocks.

Последним мы рассмотрим не менее важный способ создания ещё одного эффекта с 
помощью `canvas`, однако на этот раз мы добавим для текста текстуру так, чтобы 
он переходил в фон, как мы делали раньше с помощью SVG и CSS. Пример будет 
выглядеть так:

![пример№9][поцарапанный текст]

Мы будем использовать изображение с альфа-каналом в качестве «маски» и текст 
должен отрисовываться только там, где он пересекается с чёрными участками 
изображения и должен быть «стёрт» в прозрачных местах изображения. Значит, нам 
нужно чтобы наши исходный и целевой элементы отрисовывались только на участках 
взаимного пересечения. По этой логике и исходя из скриншота значений 
`globalCompositeOperation`, представленного выше, чтобы получить желаемый 
результат, нам нужно использовать значение `source-in`.

Ниже представлено изображение, которое мы будем использовать в качестве «маски». 
Чёрные участки - это места пересечения изображения с текстом. Так же как и в 
части про CSS-маски, представьте что текст и изображение - это два отдельных 
слоя, разместите их один над другим и затем сотрите все части текста и 
изображения, где они не пересекаются друг с другом, вы получите конечный эффект, 
который является результатом применения значения `source-in`.

![мазки][мазки]

Код Javascript такой же как и выше, только значение для 
`globalCompositeOperation` другое, так что мы перейдём сразу к живому примеру, 
где можно посмотреть исходный код и поковыряться в нём.

**Взгляните на [пример 9][35] в действии**

Здесь мы снова добавили для `canvas` фон, чтобы эффект перехода текста в фон 
выглядел немного реалистичнее. У нас получился «поцарапанный» фон с поцарапанным 
текстом, которые прекрасно сочетаются.

## Анимирование фона текста

Можно не только добавить фон для текста, но и анимировать этот фон и создать 
изящный эффект взаимодействия с ним. Так как темой этой статьи являются приёмы 
добавления фона/текстуры для текста, мы не будем рассматривать способы 
анимирования фона, из этого может получиться целая отдельная статья.

Мери Лу (Mary Lou) написала [статью][36] об эксперименте с CSS свойством 
`background-clip: text` и создании изящных эффектов для фона текста, обязательно 
почитайте её.

Трент Уолтон (Trent Walton) также написал [статью][37], в которой описал 
создание текста с фоном из градиента и анимирование этого фона, которое даёт 
очень красивый и простой эффект.

И как всегда, несколько очень креативных экспериментов над CSS свойством 
`background-clip` с применением анимации CSS можно найти на [Codepen][38], среди 
них хотелось бы выделить вот этот [действительно крутой эксперимент][39] от 
Лукаса Бебера (Lucas Bebber), в котором он создал интересный эффект заполнения 
текста водой и предложил фолбек для браузеров, не поддерживающих 
`background-clip: text`, так что взгляните и на него и поиграйте с кодом, в нём 
использованы очень крутые приёмы для создания эффекта заполнения водой.

## Использование изображения вместо текста

Вследствие отсутствия поддержки браузеров для большинства приёмов, которые 
используются для создания эффекта текстурного текста, большое количество 
разработчиков прибегает к приёмам использования изображения вместо текста с 
графикой.

За последние годы появилось множество приёмов и Крис Койер (Chris Coyier) 
проделал огромную работу по сбору всех этих приёмов с их плюсами и минусами в 
так называемый [Музей использования изображения вместо текста на основе CSS][40].

Если вы не хотите использовать ни один из описанных выше приёмов для создания 
текста с графическим эффектом, а вместо этого предпочитаете использовать один из 
существующих приёмов замены текста изображением, непременно взгляните на самый 
свежий приём от Скота Келлума (Scott Kellum), который он назвал «Новым методом 
Келлума». Этот приём предполагает использования в своём роде «пустого» шрифта, 
добавленного через правило `@font-face`; символы этого шрифта не имеют ширину 
или начертание, что делает текст невидимым и, следовательно, позволяет избежать 
применения других приёмов, предполагающих скрытие исходного текста чтобы виден 
был только его фон.

Есть много статей с подробным разбором приёмов замены текста изображением, и 
поскольку они не вписываются в тему данного руководства, которая состоит в 
описании приёмов создания декоративного текста *без* замены текста изображением, 
я лишь предоставлю ссылки на несколько источников, которые рекомендую почитать 
если вы хотите знать больше о приёмах замены текста изображением:

* [Музей использования изображения вместо текста на основе CSS][41] на CSS-Tricks
* [Замена хака -9999px][42] (Метод Келлума), автор Джефри Зельдман (Jeffrey Zeldman)
* [Ещё один приём замены текста изображением с помощью CSS][43], автор Николас Галахер (Nicolas Gallagher)
* [Новый метод Келлума][44], автор Скот Келлум (Scott Kellum)

## Заключение

Надеюсь вы научились одному-двум полезным приёмам из этой статьи. Думаю мы 
рассмотрели большинство возможных способов создания текстурного текста с помощью 
CSS и HTML. Моим любимым является приём с использованием SVG, просто из-за его 
хорошей поддержки браузерами. Когда придёт тот день, когда все браузеры будут 
поддерживать CSS-маски и значение `text` свойства `background-clip`, мы сможем 
использовать их без необходимости добавления фолбеков и тогда лучшим выбором без 
сомнения станет приём на CSS.

Надеюсь эта статья была для вас интересной. Спасибо что прочитали её! =)

*Вы знаете другие способы добавления текстуры для текста? Если да, пожалуйста, 
поделитесь ими в комментариях ниже.*

[1]: http://dev.w3.org/csswg/css-backgrounds/#the-background-clip
[2]: http://css-tricks.com/transparent-borders-with-background-clip/
[3]: http://caniuse.com/#search=background-clip
[4]: https://www.webkit.org/blog/164/background-clip-text/
[5]: https://github.com/TimPietrusky/background-clip-text-polyfill
[6]: http://css-tricks.com/image-under-text/
[7]: http://tympanus.net/Tutorials/TexturedText/index.html
[8]: http://nimbupani.com/using-background-clip-for-text-with-css-fallback.html
[9]: http://codepen.io/rachelnabors/pen/hacbD
[10]: http://codepen.io/rss/full/pxuzb
[11]: http://caniuse.com/#search=mask
[12]: http://www.w3.org/TR/css-masking/
[13]: http://www.w3.org/TR/css-masking/#the-mask-image
[14]: http://tympanus.net/Tutorials/TexturedText/index2.html
[15]: http://www.w3.org/TR/css-masking/
[16]: http://trentwalton.com/2011/05/19/mask-image-text/
[17]: http://www.w3.org/TR/SVG/masking.html#EstablishingANewClippingPath
[18]: http://tympanus.net/Tutorials/TexturedText/index3.html
[19]: http://modernizr.com/
[20]: https://github.com/TimPietrusky/background-clip-text-polyfill
[21]: http://subtlepatterns.com/
[22]: http://tympanus.net/Tutorials/TexturedText/index4.html
[23]: http://tympanus.net/Tutorials/TexturedText/index5.html
[24]: http://www.w3.org/TR/SVG/masking.html
[25]: http://tympanus.net/Tutorials/TexturedText/index6.html
[26]: http://thenittygritty.co/css-masking
[27]: http://updates.html5rocks.com/2012/12/Canvas-driven-background-images
[28]: https://bugzilla.mozilla.org/show_bug.cgi?id=707806
[29]: http://tympanus.net/Tutorials/TexturedText/index7.html
[30]: https://developers.google.com/fonts/docs/webfont_loader
[31]: https://developer.mozilla.org/samples/canvas-tutorial/6_1_canvas_composite.html
[32]: http://tympanus.net/Tutorials/TexturedText/index8.html
[33]: http://www.rekim.com/tag/globalcompositeoperation/
[34]: http://www.html5rocks.com/en/tutorials/canvas/texteffects/
[35]: http://tympanus.net/Tutorials/TexturedText/index9.html
[36]: http://tympanus.net/codrops/2011/12/12/experiments-with-background-clip-text/
[37]: http://trentwalton.com/bgclip/
[38]: http://codepen.io/
[39]: http://codepen.io/lbebber/pen/xrwja
[40]: http://css-tricks.com/examples/ImageReplacement/
[41]: http://css-tricks.com/examples/ImageReplacement/
[42]: http://www.zeldman.com/2012/03/01/replacing-the-9999px-hack-new-image-replacement/
[43]: http://nicolasgallagher.com/another-css-image-replacement-technique/
[44]: http://scottkellum.com/2013/10/25/the-new-kellum-method.html

[текстурный текст]: img/textured-text-demo1.png
[текст с эффектом акварельных пятен]: img/textured-text-demo2.png
[изображение с альфа-прозрачностью]: img/splatter-mask_1-codrops.png
[текст с обрезанным по его контуру фоном]: img/demo3.jpg
[текст с узором, имитирующим дерево]: img/demo4.jpg
[текст, залитый градиентом]: img/demo5.jpg
[текст с эффектом акварели]: img/demo6.jpg
[маска яркости]: img/luminance-mask-codrops.png
[текст с водной текстурой]: img/demo7.jpg
[текст с огненной текстурой]: img/demo8.jpg
[примеры композиции canvas]: img/canvas-composite-ru.png
[поцарапанный текст]: img/demo9.jpg
[мазки]: img/brushed-codrops.png